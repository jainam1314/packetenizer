# Backend Module Design

## Purpose
- The backend module's main purpose is to serve the information generated by core module in a formally accepted JSON format.
- It should also be able to handle file uploads and serve the static frontend files.
- It should be able to differentiate between various requests through the use of cookies.
- (Maybe) Render dashboard pages.

## Framework
- In order to achieve the above mentioned requirements, we will be using [Flask Micro Framework](https://flask.palletsprojects.com/en/1.1.x/).
- Flask on it's own is a lightweight WSGI web application framework in Python.
- It doesn't come with everything and various packages need to be installed in order to get certain features. E.g. you may need to install [Jinja](https://jinja.palletsprojects.com/en/2.11.x/) to template documents.

## Serialization
- The core module stores info in class variables. This information has to be serialized in a dictionary format which Flask can then convert into JSON and send as a response.
- Each class (CoreStructure, IPPacket, UDPDatagram, TCPSegement, DNS, Invalid) has to implement a serialize method which returns a dictionary that holds necessary information that needs to be transferred.
- Analyzer module itself returns a dictionary but some modifications may still be necessary.

## Cookies
- It is important to realize that we need a way to differentiate queries depending on the host who is requesting, i.e. we don't want to send the same reponse to everyone who makes request at a resource.
- We can either add a random id to url itself or instead send a readonly cookie that stores this value. Any queries made further will have that cookie in the response that can be used in our views.
- A new cookie will be sent anytime a new file is uploaded.
- The way to do this is to have a dictionary that is keyed using this random number, the value will be the serialized dictionary.
- This dictionary has to be looked up anytime an API request is made.
- If the key or cookie itself doesn't exist it means it's an invalid request and in such case redirect the user to landing page with possibly a message that states the error.

## Views
- `GET/` -> This should return the index.html file i.e. the landing page.
- `POST/file` -> The dump file should be POSTed to this route. Should generate the random number that will be sent in cookie. The parsing and analyzation of file should happen here. Various errors can be generated. File not valid, error during parsing, error created in our module etc. In any error redirect user back to / and state error message. If everything is successful generate the serialized dictionary and store it in lookup dictionary. Redirect the user to /dashboard with the cookie set.
- `GET/dashboard` -> This should return an overview page for all connections. Use `analyze` data.
- `GET/dashboard/tcp` -> This should return a page listing all TCP connections. Use `tcp` data.
- `GET/dashboard/udp` -> This should return a page listing all UDP connections. Use `udp` data.
- `GET/dashboard/dns` -> This should return a page listing all DNS connections. Use `dns` data.
- `GET/dashboard/icmp` -> This should return a page listing all ICMP connections. Use `icmp` data.
- `GET/dashboard/invalid` -> This should return a page listing all INVALID connections. Use `invalid` data.
- `GET/dashboard/analyze` -> This should return a page dedicated for analyzed data. Use `analyze` data.
- `GET/share/<id>` -> This should set the session id same as the one received in URL provided the id exists so that the particular data can be shared.

## Doubts
- Whether to just send data via /api routes and render the data using AJAX in frontend or to render the pages server side using Jinja.
- If server side rendering is decided then /api routes are not needed.
- The dictionary lookup can potentially lead to memory leak, a cron job can be created which runs a specific script which can clear the dictionary.

## Data Shape
```
{
    // /api/tcp
    'tcp': [
        {
            'ip': {
                'source_address',
                'destination_address',
                'version',
            },
            's_port',
            'd_port',
            'download',
            'upload',
            'protocol',
            'start_time',
            'avg_rec_time',
            'avg_trans_time',
            'unintended',
            'connection_finished',
            'invisible',
        },
    ],
    // /api/udp
    'udp': [
        {
            'ip': {
                'source_address',
                'destination_address',
                'version',
            },
            's_port',
            'd_port',
            'download',
            'upload',
            'protocol',
            'start_time',
            'avg_rec_time',
            'avg_trans_time',
            'invisible',
        },
    ],
    // /api/dns
    'dns': [
        {
            'ip': {
                'source_address',
                'destination_address',
                'version',
            },
            'transport_layer_protocol',
            'requested_domain',
            'response_ip',
            'record_type',
            'response_time',
            'server'
            'invisible',
        },
    ],
    // /api/icmp
    'icmp': [
        {
            'ip': {
                'source_address',
                'destination_address',
                'version',
            },
            'packet_type',
            'id',
            'total_requests',
            'responded_resquests',
            'start_time',
            'average_ping',
            'invisible',
        },
    ],
    // /api/invalid
    'invalid': [
        {
            'layer2_protocol',
            'layer3_protocol',
        },
    ],
    // /api/analyze
    'analyze': {
        'counts': {
            'tcp_downloaded': 0,
            'tcp_uploaded': 0,
            'udp_downloaded': 0,
            'udp_uploaded': 0,
            'threats': 0,
            'tcp_con': 0,
            'udp_con': 0,
        },
        'tcp': [
            {
                'source_address',
                'destination_address',
                'is_dos',
                'is_nmap',
                'connections',
                'unintended',
                'avg_rec',
                'avg_trans',
                'uploaded',
                'downloaded',
            }
        ],
        'udp': [
            {
                'source_address',
                'destination_address',
                'is_dos',
                'connections',
                'avg_rec',
                'avg_trans',
                'uploaded',
                'downloaded',
            },
        ],
        'dns': [
            {
                'server',
                'avg_response_time',
                'queries_resolved',
                'total_queries',
            },
        ],
        'icmp': [
            {
                'source_address',
                'destination_address',
                'avg_ping',
                'connections',
                'total_packets'
            },
        ],
        'invalid': [
            'source_address',
            'destination_address',
            'count'
        ],
    },
}
```